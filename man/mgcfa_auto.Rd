% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mgcfa.R
\name{mgcfa_auto}
\alias{mgcfa_auto}
\title{Run Automatic MGCFA from Raw Data or Matrices}
\usage{
mgcfa_auto(
  model_type = c("custom", "single_factor", "efa", "pca"),
  model = NULL,
  variables = NULL,
  n_factors = 1L,
  loading_threshold = 0.3,
  rotation = "oblimin",
  allow_cross_loadings = FALSE,
  data = NULL,
  group = NULL,
  sample_cov = NULL,
  sample_mean = NULL,
  sample_nobs = NULL,
  group_labels = NULL,
  matrices_are_cor = FALSE,
  sample_sd = NULL,
  include_steps = c("configural", "metric", "scalar", "strict", "lv.variances",
    "lv.covariances", "residual.covariances", "means"),
  partial = NULL,
  estimator = NULL,
  std.lv_configural = TRUE,
  std.lv_constrained = FALSE,
  orthogonal = FALSE,
  fit_measures = c("chisq", "df", "npar", "cfi", "tli", "rmsea", "rmsea.ci.lower",
    "rmsea.ci.upper", "srmr", "aic", "bic"),
  partial_failure_criterion = c("chisq_pvalue", "delta_cfi", "aic_bic_weight",
    "measure_change", "none"),
  partial_failure_threshold = NULL,
  partial_failure_measure = "aic",
  partial_failure_direction = c("decrease", "increase"),
  partial_failure_rules = NULL,
  partial_failure_rule_policy = c("all", "majority", "any", "at_least"),
  partial_failure_rule_min = NULL,
  partial_failure_rules_by_step = NULL,
  partial_failure_rule_policy_by_step = NULL,
  partial_failure_rule_min_by_step = NULL,
  partial_auto_search = c("prompt", "never", "always"),
  partial_search_criterion = NULL,
  partial_search_threshold = NULL,
  partial_search_measure = NULL,
  partial_search_direction = NULL,
  partial_ic_bic_weight = 0.5,
  partial_search_max_free = NULL,
  partial_search_top_n = 5L,
  partial_search_stop_on_accept = TRUE,
  partial_search_rank = c("closest", "best"),
  partial_search_use_best_if_no_pass = TRUE,
  partial_search_rules = NULL,
  partial_search_rule_policy = c("all", "majority", "any", "at_least"),
  partial_search_rule_min = NULL,
  partial_search_rules_by_step = NULL,
  partial_search_rule_policy_by_step = NULL,
  partial_search_rule_min_by_step = NULL,
  partial_search_candidate_source = c("auto", "score", "all"),
  partial_search_exhaustive_steps = c("lv.variances", "lv.covariances",
    "residual.covariances", "regressions", "means"),
  partial_search_max_models = 5000L,
  partial_search_parallel = FALSE,
  partial_search_n_cores = 2L,
  partial_search_allow_full_release = FALSE,
  partial_search_full_release_action = c("exploratory", "eligible"),
  means_constrain_lv_variances = TRUE,
  stop_at_first_unacceptable = TRUE,
  not_applicable_action = c("skip", "warn", "error")
)
}
\arguments{
\item{model_type}{One of \code{"custom"}, \code{"single_factor"},
\code{"efa"}, or \code{"pca"}.}

\item{model}{Lavaan syntax when \code{model_type = "custom"}.}

\item{variables}{Variables used for model generation in non-custom modes.}

\item{n_factors}{Number of factors/components for EFA/PCA generation.}

\item{loading_threshold}{Absolute loading threshold for EFA/PCA/PCA-derived
syntax.}

\item{rotation}{Rotation for exploratory model generation.}

\item{allow_cross_loadings}{Logical for EFA/PCA syntax generation.}

\item{data}{Raw-data input (data.frame) for multi-group SEM.}

\item{group}{Grouping variable name in \code{data}.}

\item{sample_cov}{Matrix or list of group covariance/correlation matrices.}

\item{sample_mean}{Optional vector/list of group means (required for scalar
and stricter steps in matrix mode).}

\item{sample_nobs}{Scalar, vector, or list of group sample sizes in matrix
mode.}

\item{group_labels}{Optional explicit group labels.}

\item{matrices_are_cor}{Logical. If \code{TRUE}, \code{sample_cov} is treated
as correlation matrices and converted using \code{sample_sd}.}

\item{sample_sd}{Group SD vectors used when \code{matrices_are_cor = TRUE}.}

\item{include_steps}{Character vector of invariance steps to fit.}

\item{partial}{Optional named list where each element is a
\code{group.partial} character vector for a step.}

\item{estimator}{Optional lavaan estimator.}

\item{std.lv_configural}{\code{std.lv} setting for the configural step.}

\item{std.lv_constrained}{\code{std.lv} setting for constrained steps.}

\item{orthogonal}{Passed to lavaan.}

\item{fit_measures}{Fit statistics extracted from each fitted step.}

\item{partial_failure_criterion}{Criterion used to decide whether a constrained
invariance step failed relative to the previous step in the fitted
sequence. One of
\code{"chisq_pvalue"}, \code{"delta_cfi"}, \code{"aic_bic_weight"},
\code{"measure_change"}, or \code{"none"}.}

\item{partial_failure_threshold}{Threshold used with
\code{partial_failure_criterion}. Defaults are \code{0.05} for
\code{"chisq_pvalue"}, \code{0.01} for \code{"delta_cfi"},
\code{0.5} for \code{"aic_bic_weight"}, and \code{0} for
\code{"measure_change"}.}

\item{partial_failure_measure}{Fit measure used when
\code{partial_failure_criterion = "measure_change"}.}

\item{partial_failure_direction}{Direction used when
\code{partial_failure_criterion = "measure_change"}.}

\item{partial_failure_rules}{Optional list of rule objects for multi-metric
failure decisions. Each rule is a named list with at least
\code{criterion}, and optionally \code{threshold}, \code{measure},
\code{direction}, and \code{ic_bic_weight}.}

\item{partial_failure_rule_policy}{Aggregation policy for multi-rule failure
decisions: \code{"all"}, \code{"majority"}, \code{"any"}, or
\code{"at_least"}.}

\item{partial_failure_rule_min}{Minimum number of passing rules required when
\code{partial_failure_rule_policy = "at_least"}.}

\item{partial_failure_rules_by_step}{Optional named list of step-specific
multi-rule definitions overriding \code{partial_failure_rules}.}

\item{partial_failure_rule_policy_by_step}{Optional named vector/list of
step-specific aggregation policies for failure decisions.}

\item{partial_failure_rule_min_by_step}{Optional named vector/list of
step-specific minimum pass counts for failure decisions.}

\item{partial_auto_search}{Behavior when a constrained step fails:
\code{"prompt"}, \code{"never"}, or \code{"always"}.}

\item{partial_search_criterion}{Criterion used during automatic partial
invariance search. One of \code{"chisq_pvalue"}, \code{"delta_cfi"},
\code{"aic_bic_weight"}, or \code{"measure_change"}.}

\item{partial_search_threshold}{Threshold used for
\code{partial_search_criterion}.}

\item{partial_search_measure}{Fit measure used when
\code{partial_search_criterion = "measure_change"}. Defaults to
\code{partial_failure_measure}.}

\item{partial_search_direction}{Direction used when
\code{partial_search_criterion = "measure_change"}. Defaults to
\code{partial_failure_direction}.}

\item{partial_ic_bic_weight}{Weight on BIC when
\code{partial_failure_criterion} or \code{partial_search_criterion} is
\code{"aic_bic_weight"}. The AIC weight is
\code{1 - partial_ic_bic_weight}.}

\item{partial_search_max_free}{Maximum number of additional constraints to
free during automatic partial search at the failed step.}

\item{partial_search_top_n}{Number of closest candidate models returned from
partial search.}

\item{partial_search_stop_on_accept}{Logical; stop search at first acceptable
candidate when \code{TRUE}.}

\item{partial_search_rank}{Ranking for candidate output:
\code{"closest"} or \code{"best"}.}

\item{partial_search_use_best_if_no_pass}{Logical; if no candidate meets the
threshold, continue invariance testing using the best ranked candidate.}

\item{partial_search_rules}{Optional list of rule objects for multi-metric
partial-search acceptance decisions. Rule format matches
\code{partial_failure_rules}.}

\item{partial_search_rule_policy}{Aggregation policy for multi-rule search
decisions: \code{"all"}, \code{"majority"}, \code{"any"}, or
\code{"at_least"}.}

\item{partial_search_rule_min}{Minimum number of passing rules required when
\code{partial_search_rule_policy = "at_least"}.}

\item{partial_search_rules_by_step}{Optional named list of step-specific
multi-rule definitions overriding \code{partial_search_rules}.}

\item{partial_search_rule_policy_by_step}{Optional named vector/list of
step-specific aggregation policies for partial-search decisions.}

\item{partial_search_rule_min_by_step}{Optional named vector/list of
step-specific minimum pass counts for partial-search decisions.}

\item{partial_search_candidate_source}{Candidate release-term source.
\code{"score"} uses only score-test releasable constraints,
\code{"all"} uses all releasable equality terms detected for the step,
and \code{"auto"} uses \code{"all"} for
\code{partial_search_exhaustive_steps} and \code{"score"} otherwise.}

\item{partial_search_exhaustive_steps}{Steps that should default to exhaustive
release-term enumeration when \code{partial_search_candidate_source = "auto"}.
Defaults to \code{c("lv.variances", "lv.covariances",
  "residual.covariances", "regressions", "means")}.}

\item{partial_search_max_models}{Maximum number of candidate models evaluated
during automatic partial search for a step.}

\item{partial_search_parallel}{Logical; if \code{TRUE}, evaluate partial
candidates in parallel where supported.}

\item{partial_search_n_cores}{Number of worker cores used when
\code{partial_search_parallel = TRUE}.}

\item{partial_search_allow_full_release}{Logical; if \code{TRUE}, allow
candidate models that free all step-specific equality constraints. These
candidates are flagged as \code{stage_reached = FALSE}. Whether they are
treated as acceptable fallbacks is controlled by
\code{partial_search_full_release_action}. For
\code{"lv.variances"}, \code{"lv.covariances"},
\code{"residual.covariances"}, \code{"regressions"}, and
\code{"means"} with exactly one releasable term, the fully freed
candidate is evaluated automatically as an exploratory comparison even
when this argument is \code{FALSE}.}

\item{partial_search_full_release_action}{How fully freed candidates are
treated when included. \code{"exploratory"} keeps them non-acceptable
(stage-not-reached), while \code{"eligible"} allows them to be selected as
acceptable fallbacks when decision rules pass.}

\item{means_constrain_lv_variances}{Logical; if \code{TRUE} (default), the
\code{"means"} stage also constrains latent variances. If \code{FALSE},
latent variances are left unconstrained while testing mean invariance.}

\item{stop_at_first_unacceptable}{Logical; if \code{TRUE}, stop fitting
higher invariance stages after the first constrained stage that remains
unacceptable relative to the previous fitted stage.}

\item{not_applicable_action}{Action when a requested stage has no releasable
constraints (\code{"skip"}, \code{"warn"}, or \code{"error"}).}
}
\value{
An object of class \code{"mgcfa_result"}.
}
\description{
Fits a sequential multi-group SEM/CFA invariance workflow with a model
supplied directly or generated from single-factor, EFA, or PCA templates.
}
